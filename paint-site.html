<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Paint Editor</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f8fafc; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for longer content */
            min-height: 100vh;
            padding: 1rem;
            overflow-y: auto; /* Allow scrolling if content overflows */
        }

        .editor-container {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            max-width: 960px;
            width: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background-color: #1e3a8a; /* Dark blue header */
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.75rem; /* text-2xl */
            font-weight: 700;
            text-align: center;
            border-bottom: 1px solid #1a202c;
        }

        .toolbar {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            padding: 1rem;
            background-color: #e2e8f0; /* Light gray toolbar */
            border-bottom: 1px solid #cbd5e1;
        }

        .tool-btn {
            padding: 0.6rem 1rem;
            background-color: #cbd5e1; /* Default tool background */
            color: #334155; /* Dark gray text */
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            min-width: 80px;
            text-align: center;
        }
        .tool-btn:hover {
            background-color: #a0aec0;
            transform: translateY(-1px);
        }
        .tool-btn.active {
            background-color: #3b82f6; /* Active tool blue */
            color: white;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .tool-settings {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: center;
            padding: 0.5rem;
            background-color: #f1f5f9; /* Lighter background for settings */
            border-radius: 8px;
        }

        .tool-settings label {
            font-size: 0.875rem;
            color: #475569;
        }

        .tool-settings input[type="color"] {
            width: 40px;
            height: 40px;
            border: 2px solid #a0aec0;
            border-radius: 4px;
            cursor: pointer;
        }
        .tool-settings input[type="range"] {
            width: 100px;
            -webkit-appearance: none;
            height: 8px;
            background: #cbd5e1;
            border-radius: 5px;
            outline: none;
            cursor: pointer;
        }
        .tool-settings input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
            margin-top: -5px; /* Adjust thumb position */
        }
        .tool-settings input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }

        .canvas-area {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #eef2f6; /* Canvas background area */
            padding: 1.5rem;
        }

        #drawing-canvas {
            background-color: #ffffff; /* Actual canvas background */
            border: 1px solid #cbd5e1;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.1);
            touch-action: none; /* Prevent default touch gestures */
            cursor: crosshair; /* Indicate drawing */
            border-radius: 4px;
        }

        .status-bar {
            background-color: #e2e8f0;
            color: #475569;
            padding: 0.75rem 1.5rem;
            font-size: 0.875rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #cbd5e1;
        }
        .status-message {
            font-weight: 500;
        }

        /* File & Undo/Redo Controls */
        .file-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            padding: 1rem;
            background-color: #e2e8f0; /* Same as toolbar */
            border-top: 1px solid #cbd5e1;
        }
        .file-controls .btn {
            padding: 0.6rem 1.2rem;
            background-color: #64748b; /* Slate-500 */
            color: white;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .file-controls .btn:hover {
            background-color: #475569;
            transform: translateY(-1px);
        }
        .file-controls .btn.save {
            background-color: #10b981; /* Green-500 */
        }
        .file-controls .btn.save:hover {
            background-color: #059669;
        }
        .file-controls .btn.clear {
            background-color: #ef4444; /* Red-500 */
        }
        .file-controls .btn.clear:hover {
            background-color: #dc2626;
        }
        .file-controls input[type="file"] {
            display: none; /* Hide default file input */
        }

        /* Message Box Styling */
        .message-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .message-modal.active {
            opacity: 1;
            visibility: visible;
        }
        .message-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            color: #334155;
            max-width: 380px;
            width: 90%;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }
        .message-modal.active .message-content {
            transform: translateY(0);
        }
        .message-content h2 {
            font-size: 1.75rem; /* text-2xl */
            font-weight: 700;
            margin-bottom: 1rem;
            color: #1e3a8a; /* Blue-800 */
        }
        .message-content p {
            font-size: 1rem;
            margin-bottom: 1.5rem;
            color: #475569; /* Slate-600 */
        }
        .message-content button {
            background-color: #3b82f6;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .message-content button:hover {
            background-color: #2563eb;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen">
    <div class="editor-container">
        <header class="header">
            Web Paint Editor
        </header>

        <div class="toolbar">
            <div class="tool-settings">
                <label for="color-picker">Color:</label>
                <input type="color" id="color-picker" value="#000000">
            </div>
            <div class="tool-settings">
                <label for="brush-size">Size: <span id="brush-size-value">5</span>px</label>
                <input type="range" id="brush-size" min="1" max="50" value="5">
            </div>

            <button id="brush-tool" class="tool-btn active">Brush</button>
            <button id="eraser-tool" class="tool-btn">Eraser</button>
            <button id="fill-tool" class="tool-btn">Fill</button>
            <button id="line-tool" class="tool-btn">Line</button>
        </div>

        <div class="canvas-area">
            <canvas id="drawing-canvas" width="800" height="450"></canvas>
        </div>

        <div class="file-controls">
            <button id="load-image-btn" class="btn">Load Image</button>
            <input type="file" id="image-input" accept="image/*" class="hidden">
            <button id="save-image-btn" class="btn save">Save Image</button>
            <button id="clear-canvas-btn" class="btn clear">Clear Canvas</button>
            <button id="undo-btn" class="btn">Undo</button>
            <button id="redo-btn" class="btn">Redo</button>
        </div>

        <div class="status-bar">
            <span id="status-message" class="status-message text-blue-700">Ready</span>
            <span>Canvas: <span id="canvas-width"></span>x<span id="canvas-height"></span></span>
        </div>
    </div>

    <!-- Message Box Modal -->
    <div id="message-modal" class="message-modal">
        <div class="message-content">
            <h2 id="modal-title"></h2>
            <p id="modal-text"></p>
            <button id="modal-close-btn">OK</button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const drawingCanvas = document.getElementById('drawing-canvas');
        const ctx = drawingCanvas.getContext('2d');

        const colorPicker = document.getElementById('color-picker');
        const brushSizeInput = document.getElementById('brush-size');
        const brushSizeValueSpan = document.getElementById('brush-size-value');

        const brushToolBtn = document.getElementById('brush-tool');
        const eraserToolBtn = document.getElementById('eraser-tool');
        const fillToolBtn = document.getElementById('fill-tool');
        const lineToolBtn = document.getElementById('line-tool');

        const loadImageBtn = document.getElementById('load-image-btn');
        const imageInput = document.getElementById('image-input');
        const saveImageBtn = document.getElementById('save-image-btn');
        const clearCanvasBtn = document.getElementById('clear-canvas-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');

        const statusMessageSpan = document.getElementById('status-message');
        const canvasWidthSpan = document.getElementById('canvas-width');
        const canvasHeightSpan = document.getElementById('canvas-height');

        // Message Modal elements
        const messageModal = document.getElementById('message-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalText = document.getElementById('modal-text');
        const modalCloseBtn = document.getElementById('modal-close-btn');

        // --- Global State Variables ---
        let activeTool = 'brush'; // 'brush', 'eraser', 'fill', 'line'
        let currentColor = '#000000';
        let brushSize = 5;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let lineStartX = 0;
        let lineStartY = 0;

        let history = []; // Stores canvas states as DataURLs
        let historyStep = -1; // Current position in history

        // --- Utility Functions ---

        /**
         * Displays a custom modal message box.
         * @param {string} title - The title of the modal.
         * @param {string} text - The main message text.
         * @param {function} onClose - Callback function when close is clicked.
         */
        window.showMessageBox = function(title, text, onClose = null) {
            modalTitle.textContent = title;
            modalText.textContent = text;
            modalCloseBtn.textContent = 'OK';

            messageModal.classList.add('active');

            // Remove existing listeners to prevent multiple calls
            modalCloseBtn.onclick = null;

            modalCloseBtn.onclick = () => {
                messageModal.classList.remove('active');
                if (onClose) {
                    onClose();
                }
            };
        };

        /**
         * Displays a temporary status message.
         * @param {string} message - The message to display.
         * @param {string} type - 'success', 'error', 'info'.
         */
        function displayStatusMessage(message, type = 'info') {
            statusMessageSpan.textContent = message;
            statusMessageSpan.className = 'status-message'; // Reset classes

            if (type === 'success') {
                statusMessageSpan.classList.add('text-green-700');
            } else if (type === 'error') {
                statusMessageSpan.classList.add('text-red-700');
            } else { // info or default
                statusMessageSpan.classList.add('text-blue-700');
            }

            clearTimeout(window.statusMessageTimeout);
            window.statusMessageTimeout = setTimeout(() => {
                statusMessageSpan.textContent = 'Ready';
                statusMessageSpan.className = 'status-message text-blue-700';
            }, 3000);
        }

        /**
         * Saves the current canvas state to history.
         */
        function saveState() {
            if (historyStep < history.length - 1) {
                history = history.slice(0, historyStep + 1);
            }
            history.push(drawingCanvas.toDataURL());
            historyStep++;
            updateUndoRedoButtons();
        }

        /**
         * Restores a canvas state from history.
         * @param {number} step - The history step to restore to.
         */
        function restoreState(step) {
            if (step < 0 || step >= history.length) return;

            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                ctx.drawImage(img, 0, 0, drawingCanvas.width, drawingCanvas.height);
                displayStatusMessage('Restored previous state.', 'info');
            };
            img.src = history[step];
        }

        /**
         * Updates the enabled/disabled state of Undo/Redo buttons.
         */
        function updateUndoRedoButtons() {
            undoBtn.disabled = historyStep <= 0;
            redoBtn.disabled = historyStep >= history.length - 1;

            if (undoBtn.disabled) undoBtn.classList.add('opacity-50', 'cursor-not-allowed');
            else undoBtn.classList.remove('opacity-50', 'cursor-not-allowed');

            if (redoBtn.disabled) redoBtn.classList.add('opacity-50', 'cursor-not-allowed');
            else redoBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        }

        // --- Canvas Drawing Functions ---

        /**
         * Draws a dot or line segment.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         */
        function draw(x, y) {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = brushSize;

            if (activeTool === 'brush') {
                ctx.strokeStyle = currentColor;
                ctx.globalCompositeOperation = 'source-over'; // Normal drawing
            } else if (activeTool === 'eraser') {
                ctx.strokeStyle = '#FFFFFF'; // Erase with white, or transparent if using 'destination-out'
                ctx.globalCompositeOperation = 'destination-out'; // Makes pixels transparent
            }

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();

            // Reset composite operation for other tools if it was changed by eraser
            if (activeTool === 'eraser') {
                ctx.globalCompositeOperation = 'source-over';
            }

            lastX = x;
            lastY = y;
        }

        /**
         * Implements a basic flood fill algorithm.
         * @param {number} startX - Starting X coordinate.
         * @param {number} startY - Starting Y coordinate.
         * @param {string} fillColor - The fill color (hex string).
         */
        function floodFill(startX, startY, fillColor) {
            const imageData = ctx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
            const pixels = imageData.data;
            const width = drawingCanvas.width;
            const height = drawingCanvas.height;

            const targetColor = getPixelColor(pixels, startX, startY, width);
            const newColor = hexToRgb(fillColor);

            if (targetColor.r === newColor.r && targetColor.g === newColor.g && targetColor.b === newColor.b && targetColor.a === newColor.a) {
                displayStatusMessage('Target color is already the fill color.', 'info');
                return; // Already the same color
            }

            const queue = [{ x: startX, y: startY }];

            function getPixelColor(pixelData, x, y, imgWidth) {
                const index = (y * imgWidth + x) * 4;
                return {
                    r: pixelData[index],
                    g: pixelData[index + 1],
                    b: pixelData[index + 2],
                    a: pixelData[index + 3]
                };
            }

            function setPixelColor(pixelData, x, y, imgWidth, color) {
                const index = (y * imgWidth + x) * 4;
                pixelData[index] = color.r;
                pixelData[index + 1] = color.g;
                pixelData[index + 2] = color.b;
                pixelData[index + 3] = color.a;
            }

            function colorsMatch(c1, c2) {
                return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;
            }

            while (queue.length > 0) {
                const { x, y } = queue.shift();

                if (x < 0 || x >= width || y < 0 || y >= height) continue;

                const currentColorAtXY = getPixelColor(pixels, x, y, width);

                if (colorsMatch(currentColorAtXY, targetColor)) {
                    setPixelColor(pixels, x, y, width, newColor);

                    queue.push({ x: x + 1, y: y });
                    queue.push({ x: x - 1, y: y });
                    queue.push({ x: x, y: y + 1 });
                    queue.push({ x: x, y: y - 1 });
                }
            }
            ctx.putImageData(imageData, 0, 0);
            saveState(); // Save state after fill
            displayStatusMessage('Area filled.', 'success');
        }

        /**
         * Converts a hex color string to an RGBA object.
         * @param {string} hex - Hex color string (e.g., "#RRGGBB").
         * @returns {object} RGBA object.
         */
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            return {
                r: (bigint >> 16) & 255,
                g: (bigint >> 8) & 255,
                b: bigint & 255,
                a: 255 // Assume full opacity for simplicity
            };
        }


        // --- Canvas Event Handlers ---
        drawingCanvas.addEventListener('mousedown', (e) => {
            const rect = drawingCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (activeTool === 'fill') {
                floodFill(Math.floor(x), Math.floor(y), currentColor);
            } else if (activeTool === 'line') {
                isDrawing = true;
                lineStartX = x;
                lineStartY = y;
                // Temporarily store current canvas state to draw temporary line preview
                saveState(); // Save current state before drawing potential line
                // The current image is now history[historyStep]. When mouse moves, draw line over it.
            } else { // Brush or Eraser
                isDrawing = true;
                lastX = x;
                lastY = y;
                draw(x, y); // Draw a dot on click
            }
        });

        drawingCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;

            const rect = drawingCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (activeTool === 'line') {
                // Restore the state before drawing the current line preview
                restoreState(historyStep); // This redraws the canvas to the state before the line was started
                ctx.lineWidth = brushSize;
                ctx.strokeStyle = currentColor;
                ctx.beginPath();
                ctx.moveTo(lineStartX, lineStartY);
                ctx.lineTo(x, y);
                ctx.stroke();
            } else {
                draw(x, y);
            }
        });

        drawingCanvas.addEventListener('mouseup', () => {
            if (!isDrawing) return; // Only save state if something was actually drawn/started

            isDrawing = false;
            // For line tool, draw the final line and save state
            if (activeTool === 'line') {
                // The line was already drawn in mousemove and saved by restoreState.
                // Just save the final state now.
                // Re-draw the final line once more to ensure it's on the *correct* current state
                restoreState(historyStep); // Go back to state before line started
                ctx.lineWidth = brushSize;
                ctx.strokeStyle = currentColor;
                ctx.beginPath();
                ctx.moveTo(lineStartX, lineStartY);
                ctx.lineTo(lastX, lastY); // Use the last position from mousemove
                ctx.stroke();
                saveState(); // Save the state *after* the final line is drawn
            } else { // Brush or Eraser
                saveState(); // Save state after drawing stops
            }
        });

        // Prevent dragging on canvas
        drawingCanvas.addEventListener('mouseout', () => {
            if (isDrawing && (activeTool === 'brush' || activeTool === 'eraser')) {
                isDrawing = false;
                saveState();
            }
            // For line tool, mouseout should probably cancel the line or finish it
            if (isDrawing && activeTool === 'line') {
                isDrawing = false;
                restoreState(historyStep); // Cancel line preview
                displayStatusMessage('Line drawing cancelled.', 'info');
            }
        });

        // --- Toolbar & Controls Event Handlers ---
        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
            displayStatusMessage(`Color set to ${currentColor}.`);
        });

        brushSizeInput.addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            brushSizeValueSpan.textContent = brushSize;
            displayStatusMessage(`Brush size set to ${brushSize}px.`);
        });

        // Tool selection
        [brushToolBtn, eraserToolBtn, fillToolBtn, lineToolBtn].forEach(btn => {
            btn.addEventListener('click', () => {
                // Remove active class from all tool buttons
                [brushToolBtn, eraserToolBtn, fillToolBtn, lineToolBtn].forEach(b => b.classList.remove('active'));
                // Add active class to the clicked button
                btn.classList.add('active');
                activeTool = btn.id.replace('-tool', ''); // Extract tool name
                displayStatusMessage(`Active tool: ${activeTool.charAt(0).toUpperCase() + activeTool.slice(1)}.`);

                // Update cursor based on tool
                if (activeTool === 'fill') {
                    drawingCanvas.style.cursor = 'crosshair'; // Can't easily do a paint bucket icon
                } else if (activeTool === 'line') {
                    drawingCanvas.style.cursor = 'crosshair';
                } else if (activeTool === 'eraser') {
                    drawingCanvas.style.cursor = 'grab'; // Placeholder for eraser icon
                } else { // brush
                    drawingCanvas.style.cursor = 'crosshair';
                }
            });
        });

        // --- File Operations ---
        loadImageBtn.addEventListener('click', () => {
            imageInput.click(); // Trigger hidden file input
        });

        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); // Clear existing content
                        ctx.drawImage(img, 0, 0, drawingCanvas.width, drawingCanvas.height); // Draw image scaled to canvas
                        saveState(); // Save state after loading image
                        displayStatusMessage(`Image '${file.name}' loaded.`, 'success');
                    };
                    img.onerror = () => {
                        showMessageBox('Error', 'Could not load image. Please ensure it is a valid image file.');
                        displayStatusMessage('Failed to load image.', 'error');
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                displayStatusMessage('No image selected.', 'info');
            }
            e.target.value = ''; // Clear input to allow re-loading same file
        });

        saveImageBtn.addEventListener('click', () => {
            // Create a temporary link element
            const link = document.createElement('a');
            link.download = 'my-drawing.png'; // Default filename
            link.href = drawingCanvas.toDataURL('image/png'); // Get canvas content as PNG DataURL
            document.body.appendChild(link); // Required for Firefox
            link.click(); // Trigger download
            document.body.removeChild(link); // Clean up
            displayStatusMessage('Image saved as my-drawing.png.', 'success');
        });

        clearCanvasBtn.addEventListener('click', () => {
            showMessageBox('Clear Canvas?', 'Are you sure you want to clear the entire canvas? This action cannot be undone (except by Undo).', () => {
                ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                saveState(); // Save cleared state
                displayStatusMessage('Canvas cleared.', 'success');
            });
        });

        // --- Undo/Redo ---
        undoBtn.addEventListener('click', () => {
            if (historyStep > 0) {
                historyStep--;
                restoreState(historyStep);
                updateUndoRedoButtons();
            } else {
                displayStatusMessage('Cannot undo further.', 'info');
            }
        });

        redoBtn.addEventListener('click', () => {
            if (historyStep < history.length - 1) {
                historyStep++;
                restoreState(historyStep);
                updateUndoRedoButtons();
            } else {
                displayStatusMessage('Cannot redo further.', 'info');
            }
        });

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            // Set canvas dimensions display
            canvasWidthSpan.textContent = drawingCanvas.width;
            canvasHeightSpan.textContent = drawingCanvas.height;

            // Save initial empty state
            saveState();
            updateUndoRedoButtons(); // Initialize button states

            displayStatusMessage('Welcome to Web Paint Editor!');
        });
    </script>
</body>
</html>
